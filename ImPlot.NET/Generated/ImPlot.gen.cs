using System;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Text;
using ImGuiNET;

namespace ImPlotNET
{
    public static unsafe partial class ImPlot
    {
        public static void Annotate(double x, double y, Vector2 pix_offset, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_AnnotateStr(x, y, pix_offset, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void Annotate(double x, double y, Vector2 pix_offset, Vector4 color, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_AnnotateVec4(x, y, pix_offset, color, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void AnnotateClamped(double x, double y, Vector2 pix_offset, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_AnnotateClampedStr(x, y, pix_offset, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static void AnnotateClamped(double x, double y, Vector2 pix_offset, Vector4 color, string fmt)
        {
            byte* native_fmt;
            int fmt_byteCount = 0;
            if (fmt != null)
            {
                fmt_byteCount = Encoding.UTF8.GetByteCount(fmt);
                if (fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_fmt = Util.Allocate(fmt_byteCount + 1);
                }
                else
                {
                    byte* native_fmt_stackBytes = stackalloc byte[fmt_byteCount + 1];
                    native_fmt = native_fmt_stackBytes;
                }
                int native_fmt_offset = Util.GetUtf8(fmt, native_fmt, fmt_byteCount);
                native_fmt[native_fmt_offset] = 0;
            }
            else { native_fmt = null; }
            ImPlotNative.ImPlot_AnnotateClampedVec4(x, y, pix_offset, color, native_fmt);
            if (fmt_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_fmt);
            }
        }
        public static bool BeginDragDropSource()
        {
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSource(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSource(ImGuiKeyModFlags key_mods)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSource(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSource(ImGuiKeyModFlags key_mods, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSource(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceItem(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourceItem(string label_id, ImGuiDragDropFlags flags)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceItem(native_label_id, flags);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginDragDropSourceX()
        {
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceX(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceX(ImGuiKeyModFlags key_mods)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceX(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceX(ImGuiKeyModFlags key_mods, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceX(key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY()
        {
            ImPlotYAxis axis = ImPlotYAxis._1;
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY(ImPlotYAxis axis)
        {
            ImGuiKeyModFlags key_mods = ImGuiKeyModFlags.Ctrl;
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY(ImPlotYAxis axis, ImGuiKeyModFlags key_mods)
        {
            ImGuiDragDropFlags flags = 0;
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropSourceY(ImPlotYAxis axis, ImGuiKeyModFlags key_mods, ImGuiDragDropFlags flags)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropSourceY(axis, key_mods, flags);
            return ret != 0;
        }
        public static bool BeginDragDropTarget()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTarget();
            return ret != 0;
        }
        public static bool BeginDragDropTargetLegend()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetLegend();
            return ret != 0;
        }
        public static bool BeginDragDropTargetX()
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetX();
            return ret != 0;
        }
        public static bool BeginDragDropTargetY()
        {
            ImPlotYAxis axis = ImPlotYAxis._1;
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetY(axis);
            return ret != 0;
        }
        public static bool BeginDragDropTargetY(ImPlotYAxis axis)
        {
            byte ret = ImPlotNative.ImPlot_BeginDragDropTargetY(axis);
            return ret != 0;
        }
        public static bool BeginLegendPopup(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImGuiMouseButton mouse_button = (ImGuiMouseButton)1;
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginLegendPopup(string label_id, ImGuiMouseButton mouse_button)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_BeginLegendPopup(native_label_id, mouse_button);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label = null;
            byte* native_y_label = null;
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label = null;
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            Vector2 size = new Vector2(-1, 0);
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotFlags flags = ImPlotFlags.None;
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags x_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y_flags = ImPlotAxisFlags.None;
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y2_flags = ImPlotAxisFlags.NoGridLines;
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            ImPlotAxisFlags y3_flags = ImPlotAxisFlags.NoGridLines;
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            byte* native_y2_label = null;
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags, string y2_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            byte* native_y2_label;
            int y2_label_byteCount = 0;
            if (y2_label != null)
            {
                y2_label_byteCount = Encoding.UTF8.GetByteCount(y2_label);
                if (y2_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y2_label = Util.Allocate(y2_label_byteCount + 1);
                }
                else
                {
                    byte* native_y2_label_stackBytes = stackalloc byte[y2_label_byteCount + 1];
                    native_y2_label = native_y2_label_stackBytes;
                }
                int native_y2_label_offset = Util.GetUtf8(y2_label, native_y2_label, y2_label_byteCount);
                native_y2_label[native_y2_label_offset] = 0;
            }
            else { native_y2_label = null; }
            byte* native_y3_label = null;
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            if (y2_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y2_label);
            }
            return ret != 0;
        }
        public static bool BeginPlot(string title_id, string x_label, string y_label, Vector2 size, ImPlotFlags flags, ImPlotAxisFlags x_flags, ImPlotAxisFlags y_flags, ImPlotAxisFlags y2_flags, ImPlotAxisFlags y3_flags, string y2_label, string y3_label)
        {
            byte* native_title_id;
            int title_id_byteCount = 0;
            if (title_id != null)
            {
                title_id_byteCount = Encoding.UTF8.GetByteCount(title_id);
                if (title_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_title_id = Util.Allocate(title_id_byteCount + 1);
                }
                else
                {
                    byte* native_title_id_stackBytes = stackalloc byte[title_id_byteCount + 1];
                    native_title_id = native_title_id_stackBytes;
                }
                int native_title_id_offset = Util.GetUtf8(title_id, native_title_id, title_id_byteCount);
                native_title_id[native_title_id_offset] = 0;
            }
            else { native_title_id = null; }
            byte* native_x_label;
            int x_label_byteCount = 0;
            if (x_label != null)
            {
                x_label_byteCount = Encoding.UTF8.GetByteCount(x_label);
                if (x_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_x_label = Util.Allocate(x_label_byteCount + 1);
                }
                else
                {
                    byte* native_x_label_stackBytes = stackalloc byte[x_label_byteCount + 1];
                    native_x_label = native_x_label_stackBytes;
                }
                int native_x_label_offset = Util.GetUtf8(x_label, native_x_label, x_label_byteCount);
                native_x_label[native_x_label_offset] = 0;
            }
            else { native_x_label = null; }
            byte* native_y_label;
            int y_label_byteCount = 0;
            if (y_label != null)
            {
                y_label_byteCount = Encoding.UTF8.GetByteCount(y_label);
                if (y_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y_label = Util.Allocate(y_label_byteCount + 1);
                }
                else
                {
                    byte* native_y_label_stackBytes = stackalloc byte[y_label_byteCount + 1];
                    native_y_label = native_y_label_stackBytes;
                }
                int native_y_label_offset = Util.GetUtf8(y_label, native_y_label, y_label_byteCount);
                native_y_label[native_y_label_offset] = 0;
            }
            else { native_y_label = null; }
            byte* native_y2_label;
            int y2_label_byteCount = 0;
            if (y2_label != null)
            {
                y2_label_byteCount = Encoding.UTF8.GetByteCount(y2_label);
                if (y2_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y2_label = Util.Allocate(y2_label_byteCount + 1);
                }
                else
                {
                    byte* native_y2_label_stackBytes = stackalloc byte[y2_label_byteCount + 1];
                    native_y2_label = native_y2_label_stackBytes;
                }
                int native_y2_label_offset = Util.GetUtf8(y2_label, native_y2_label, y2_label_byteCount);
                native_y2_label[native_y2_label_offset] = 0;
            }
            else { native_y2_label = null; }
            byte* native_y3_label;
            int y3_label_byteCount = 0;
            if (y3_label != null)
            {
                y3_label_byteCount = Encoding.UTF8.GetByteCount(y3_label);
                if (y3_label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_y3_label = Util.Allocate(y3_label_byteCount + 1);
                }
                else
                {
                    byte* native_y3_label_stackBytes = stackalloc byte[y3_label_byteCount + 1];
                    native_y3_label = native_y3_label_stackBytes;
                }
                int native_y3_label_offset = Util.GetUtf8(y3_label, native_y3_label, y3_label_byteCount);
                native_y3_label[native_y3_label_offset] = 0;
            }
            else { native_y3_label = null; }
            byte ret = ImPlotNative.ImPlot_BeginPlot(native_title_id, native_x_label, native_y_label, size, flags, x_flags, y_flags, y2_flags, y3_flags, native_y2_label, native_y3_label);
            if (title_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_title_id);
            }
            if (x_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_x_label);
            }
            if (y_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y_label);
            }
            if (y2_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y2_label);
            }
            if (y3_label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_y3_label);
            }
            return ret != 0;
        }
        public static IntPtr CreateContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_CreateContext();
            return ret;
        }
        public static void DestroyContext()
        {
            IntPtr ctx = IntPtr.Zero;
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static void DestroyContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_DestroyContext(ctx);
        }
        public static bool DragLineX(string id, ref double x_value)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte show_label = 1;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineX(string id, ref double x_value, bool show_label)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineX(string id, ref double x_value, bool show_label, Vector4 col)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            float thickness = 1;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineX(string id, ref double x_value, bool show_label, Vector4 col, float thickness)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            fixed (double* native_x_value = &x_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineX(native_id, native_x_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte show_label = 1;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value, bool show_label)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float thickness = 1;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value, bool show_label, Vector4 col)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            float thickness = 1;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragLineY(string id, ref double y_value, bool show_label, Vector4 col, float thickness)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            fixed (double* native_y_value = &y_value)
            {
                byte ret = ImPlotNative.ImPlot_DragLineY(native_id, native_y_value, native_show_label, col, thickness);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_id);
                }
                return ret != 0;
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte show_label = 1;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float radius = 4;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y, bool show_label)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            Vector4 col = new Vector4(0, 0, 0, -1);
            float radius = 4;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, native_show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y, bool show_label, Vector4 col)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            float radius = 4;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, native_show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static bool DragPoint(string id, ref double x, ref double y, bool show_label, Vector4 col, float radius)
        {
            byte* native_id;
            int id_byteCount = 0;
            if (id != null)
            {
                id_byteCount = Encoding.UTF8.GetByteCount(id);
                if (id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_id = Util.Allocate(id_byteCount + 1);
                }
                else
                {
                    byte* native_id_stackBytes = stackalloc byte[id_byteCount + 1];
                    native_id = native_id_stackBytes;
                }
                int native_id_offset = Util.GetUtf8(id, native_id, id_byteCount);
                native_id[native_id_offset] = 0;
            }
            else { native_id = null; }
            byte native_show_label = show_label ? (byte)1 : (byte)0;
            fixed (double* native_x = &x)
            {
                fixed (double* native_y = &y)
                {
                    byte ret = ImPlotNative.ImPlot_DragPoint(native_id, native_x, native_y, native_show_label, col, radius);
                    if (id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_id);
                    }
                    return ret != 0;
                }
            }
        }
        public static void EndDragDropSource()
        {
            ImPlotNative.ImPlot_EndDragDropSource();
        }
        public static void EndDragDropTarget()
        {
            ImPlotNative.ImPlot_EndDragDropTarget();
        }
        public static void EndLegendPopup()
        {
            ImPlotNative.ImPlot_EndLegendPopup();
        }
        public static void EndPlot()
        {
            ImPlotNative.ImPlot_EndPlot();
        }
        public static void FitNextPlotAxes()
        {
            byte x = 1;
            byte y = 1;
            byte y2 = 1;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(x, y, y2, y3);
        }
        public static void FitNextPlotAxes(bool x)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte y = 1;
            byte y2 = 1;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, y, y2, y3);
        }
        public static void FitNextPlotAxes(bool x, bool y)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte native_y = y ? (byte)1 : (byte)0;
            byte y2 = 1;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, native_y, y2, y3);
        }
        public static void FitNextPlotAxes(bool x, bool y, bool y2)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte native_y = y ? (byte)1 : (byte)0;
            byte native_y2 = y2 ? (byte)1 : (byte)0;
            byte y3 = 1;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, native_y, native_y2, y3);
        }
        public static void FitNextPlotAxes(bool x, bool y, bool y2, bool y3)
        {
            byte native_x = x ? (byte)1 : (byte)0;
            byte native_y = y ? (byte)1 : (byte)0;
            byte native_y2 = y2 ? (byte)1 : (byte)0;
            byte native_y3 = y3 ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_FitNextPlotAxes(native_x, native_y, native_y2, native_y3);
        }
        public static Vector4 GetColormapColor(int index)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetColormapColor(&__retval, index);
            return __retval;
        }
        public static string GetColormapName(ImPlotColormap colormap)
        {
            byte* ret = ImPlotNative.ImPlot_GetColormapName(colormap);
            return Util.StringFromPtr(ret);
        }
        public static int GetColormapSize()
        {
            int ret = ImPlotNative.ImPlot_GetColormapSize();
            return ret;
        }
        public static IntPtr GetCurrentContext()
        {
            IntPtr ret = ImPlotNative.ImPlot_GetCurrentContext();
            return ret;
        }
        public static Vector4 GetLastItemColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_GetLastItemColor(&__retval);
            return __retval;
        }
        public static string GetMarkerName(ImPlotMarker idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetMarkerName(idx);
            return Util.StringFromPtr(ret);
        }
        public static ImDrawListPtr GetPlotDrawList()
        {
            ImDrawList* ret = ImPlotNative.ImPlot_GetPlotDrawList();
            return new ImDrawListPtr(ret);
        }
        public static ImPlotLimits GetPlotLimits()
        {
            ImPlotLimits __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_GetPlotLimits(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotLimits GetPlotLimits(ImPlotYAxis y_axis)
        {
            ImPlotLimits __retval;
            ImPlotNative.ImPlot_GetPlotLimits(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos()
        {
            ImPlotPoint __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotPoint GetPlotMousePos(ImPlotYAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_GetPlotMousePos(&__retval, y_axis);
            return __retval;
        }
        public static Vector2 GetPlotPos()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotPos(&__retval);
            return __retval;
        }
        public static ImPlotLimits GetPlotQuery()
        {
            ImPlotLimits __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_GetPlotQuery(&__retval, y_axis);
            return __retval;
        }
        public static ImPlotLimits GetPlotQuery(ImPlotYAxis y_axis)
        {
            ImPlotLimits __retval;
            ImPlotNative.ImPlot_GetPlotQuery(&__retval, y_axis);
            return __retval;
        }
        public static Vector2 GetPlotSize()
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_GetPlotSize(&__retval);
            return __retval;
        }
        public static ImPlotStylePtr GetStyle()
        {
            ImPlotStyle* ret = ImPlotNative.ImPlot_GetStyle();
            return new ImPlotStylePtr(ret);
        }
        public static string GetStyleColorName(ImPlotCol idx)
        {
            byte* ret = ImPlotNative.ImPlot_GetStyleColorName(idx);
            return Util.StringFromPtr(ret);
        }
        public static void HideNextItem()
        {
            byte hidden = 1;
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_HideNextItem(hidden, cond);
        }
        public static void HideNextItem(bool hidden)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static void HideNextItem(bool hidden, ImGuiCond cond)
        {
            byte native_hidden = hidden ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_HideNextItem(native_hidden, cond);
        }
        public static bool IsLegendEntryHovered(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte ret = ImPlotNative.ImPlot_IsLegendEntryHovered(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
            return ret != 0;
        }
        public static bool IsPlotHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotHovered();
            return ret != 0;
        }
        public static bool IsPlotQueried()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotQueried();
            return ret != 0;
        }
        public static bool IsPlotXAxisHovered()
        {
            byte ret = ImPlotNative.ImPlot_IsPlotXAxisHovered();
            return ret != 0;
        }
        public static bool IsPlotYAxisHovered()
        {
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            byte ret = ImPlotNative.ImPlot_IsPlotYAxisHovered(y_axis);
            return ret != 0;
        }
        public static bool IsPlotYAxisHovered(ImPlotYAxis y_axis)
        {
            byte ret = ImPlotNative.ImPlot_IsPlotYAxisHovered(y_axis);
            return ret != 0;
        }
        public static void ItemIcon(Vector4 col)
        {
            ImPlotNative.ImPlot_ItemIconVec4(col);
        }
        public static void ItemIcon(uint col)
        {
            ImPlotNative.ImPlot_ItemIconU32(col);
        }
        public static Vector4 LerpColormap(float t)
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_LerpColormapFloat(&__retval, t);
            return __retval;
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax)
        {
            double* ymin2 = null;
            double* ymax2 = null;
            double* ymin3 = null;
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, ymin2, ymax2, ymin3, ymax3);
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2)
        {
            double* ymax2 = null;
            double* ymin3 = null;
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, ymax2, ymin3, ymax3);
                            }
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2, ref double ymax2)
        {
            double* ymin3 = null;
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                fixed (double* native_ymax2 = &ymax2)
                                {
                                    ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, native_ymax2, ymin3, ymax3);
                                }
                            }
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2, ref double ymax2, ref double ymin3)
        {
            double* ymax3 = null;
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                fixed (double* native_ymax2 = &ymax2)
                                {
                                    fixed (double* native_ymin3 = &ymin3)
                                    {
                                        ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, native_ymax2, native_ymin3, ymax3);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        public static void LinkNextPlotLimits(ref double xmin, ref double xmax, ref double ymin, ref double ymax, ref double ymin2, ref double ymax2, ref double ymin3, ref double ymax3)
        {
            fixed (double* native_xmin = &xmin)
            {
                fixed (double* native_xmax = &xmax)
                {
                    fixed (double* native_ymin = &ymin)
                    {
                        fixed (double* native_ymax = &ymax)
                        {
                            fixed (double* native_ymin2 = &ymin2)
                            {
                                fixed (double* native_ymax2 = &ymax2)
                                {
                                    fixed (double* native_ymin3 = &ymin3)
                                    {
                                        fixed (double* native_ymax3 = &ymax3)
                                        {
                                            ImPlotNative.ImPlot_LinkNextPlotLimits(native_xmin, native_xmax, native_ymin, native_ymax, native_ymin2, native_ymax2, native_ymin3, native_ymax3);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        public static Vector4 NextColormapColor()
        {
            Vector4 __retval;
            ImPlotNative.ImPlot_NextColormapColor(&__retval);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix)
        {
            ImPlotPoint __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlotVec2(&__retval, pix, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(Vector2 pix, ImPlotYAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlotVec2(&__retval, pix, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y)
        {
            ImPlotPoint __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PixelsToPlotFloat(&__retval, x, y, y_axis);
            return __retval;
        }
        public static ImPlotPoint PixelsToPlot(float x, float y, ImPlotYAxis y_axis)
        {
            ImPlotPoint __retval;
            ImPlotNative.ImPlot_PixelsToPlotFloat(&__retval, x, y, y_axis);
            return __retval;
        }
        public static void PlotBars(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsFloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsFloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsFloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsFloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsFloatPtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsdoublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsdoublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsdoublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsdoublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref double values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsdoublePtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref byte values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU8PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref short values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU16PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref int values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref uint values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU32PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref long values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsS64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double width = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong values, int count, double width, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsU64PtrInt(native_label_id, native_values, count, width, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref float xs, ref float ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref double xs, ref double ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref sbyte xs, ref sbyte ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref byte xs, ref byte ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref short xs, ref short ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ushort xs, ref ushort ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref int xs, ref int ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref uint xs, ref uint ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref long xs, ref long ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double width)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double width, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBars(string label_id, ref ulong xs, ref ulong ys, int count, double width, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, width, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHFloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHFloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHFloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHFloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHFloatPtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHdoublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHdoublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHdoublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHdoublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHdoublePtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU8PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU16PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU32PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHS64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double height = 0.67;
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double shift = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height, double shift)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height, double shift, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong values, int count, double height, double shift, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotBarsHU64PtrInt(native_label_id, native_values, count, height, shift, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float xs, ref float ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float xs, ref float ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref float xs, ref float ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double xs, ref double ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double xs, ref double ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref double xs, ref double ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte xs, ref sbyte ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte xs, ref sbyte ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref sbyte xs, ref sbyte ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte xs, ref byte ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte xs, ref byte ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref byte xs, ref byte ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short xs, ref short ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short xs, ref short ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref short xs, ref short ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort xs, ref ushort ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort xs, ref ushort ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ushort xs, ref ushort ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int xs, ref int ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int xs, ref int ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref int xs, ref int ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint xs, ref uint ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint xs, ref uint ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref uint xs, ref uint ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long xs, ref long ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long xs, ref long ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref long xs, ref long ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong xs, ref ulong ys, int count, double height)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong xs, ref ulong ys, int count, double height, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotBarsH(string label_id, ref ulong xs, ref ulong ys, int count, double height, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotBarsHU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, height, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitaldoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitaldoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitaldoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDigital(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotDigitalU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotDummy(string label_id)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotDummy(native_label_id);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsFloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsFloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsFloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsdoublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsdoublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsdoublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsS64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsU64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsFloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsFloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsFloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsdoublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsdoublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsdoublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsS64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBars(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsU64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHFloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHFloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHFloatPtrFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHdoublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHdoublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHdoublePtrdoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS8PtrS8PtrS8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU8PtrU8PtrU8PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS16PtrS16PtrS16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU16PtrU16PtrU16PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS32PtrS32PtrS32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU32PtrU32PtrU32PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHS64PtrS64PtrS64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong err, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_err = &err)
                    {
                        ImPlotNative.ImPlot_PlotErrorBarsHU64PtrU64PtrU64PtrInt(native_label_id, native_xs, native_ys, native_err, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHFloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHFloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref float xs, ref float ys, ref float neg, ref float pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    fixed (float* native_neg = &neg)
                    {
                        fixed (float* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHFloatPtrFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHdoublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHdoublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref double xs, ref double ys, ref double neg, ref double pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    fixed (double* native_neg = &neg)
                    {
                        fixed (double* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHdoublePtrdoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref sbyte xs, ref sbyte ys, ref sbyte neg, ref sbyte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    fixed (sbyte* native_neg = &neg)
                    {
                        fixed (sbyte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS8PtrS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref byte xs, ref byte ys, ref byte neg, ref byte pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    fixed (byte* native_neg = &neg)
                    {
                        fixed (byte* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU8PtrU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref short xs, ref short ys, ref short neg, ref short pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    fixed (short* native_neg = &neg)
                    {
                        fixed (short* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS16PtrS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ushort xs, ref ushort ys, ref ushort neg, ref ushort pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    fixed (ushort* native_neg = &neg)
                    {
                        fixed (ushort* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU16PtrU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref int xs, ref int ys, ref int neg, ref int pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    fixed (int* native_neg = &neg)
                    {
                        fixed (int* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS32PtrS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref uint xs, ref uint ys, ref uint neg, ref uint pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    fixed (uint* native_neg = &neg)
                    {
                        fixed (uint* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU32PtrU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref long xs, ref long ys, ref long neg, ref long pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    fixed (long* native_neg = &neg)
                    {
                        fixed (long* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHS64PtrS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotErrorBarsH(string label_id, ref ulong xs, ref ulong ys, ref ulong neg, ref ulong pos, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    fixed (ulong* native_neg = &neg)
                    {
                        fixed (ulong* native_pos = &pos)
                        {
                            ImPlotNative.ImPlot_PlotErrorBarsHU64PtrU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys, native_neg, native_pos, count, offset, stride);
                            if (label_id_byteCount > Util.StackAllocationSizeLimit)
                            {
                                Util.Free(native_label_id);
                            }
                        }
                    }
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapFloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapFloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapFloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref float values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapFloatPtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapdoublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapdoublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapdoublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref double values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapdoublePtr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref sbyte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref byte values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU8Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref short values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ushort values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU16Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref int values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref uint values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU32Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref long values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapS64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_min = new ImPlotPoint { x = 0, y = 0 };
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            ImPlotPoint bounds_max = new ImPlotPoint { x = 1, y = 1 };
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHeatmap(string label_id, ref ulong values, int rows, int cols, double scale_min, double scale_max, string label_fmt, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotHeatmapU64Ptr(native_label_id, native_values, rows, cols, scale_min, scale_max, native_label_fmt, bounds_min, bounds_max);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotHLines(string label_id, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesFloatPtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesFloatPtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesFloatPtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesdoublePtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesdoublePtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesdoublePtr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU8Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU16Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU32Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesS64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotHLines(string label_id, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_ys = &ys)
            {
                ImPlotNative.ImPlot_PlotHLinesU64Ptr(native_label_id, native_ys, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv0 = new Vector2();
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector2 uv1 = new Vector2(1, 1);
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            Vector4 tint_col = new Vector4(1, 1, 1, 1);
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotImage(string label_id, IntPtr user_texture_id, ImPlotPoint bounds_min, ImPlotPoint bounds_max, Vector2 uv0, Vector2 uv1, Vector4 tint_col)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            ImPlotNative.ImPlot_PlotImage(native_label_id, user_texture_id, bounds_min, bounds_max, uv0, uv1, tint_col);
            if (label_id_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label_id);
            }
        }
        public static void PlotLine(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLinedoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLinedoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLinedoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLinedoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref double values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLinedoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref byte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref short values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref int values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref uint values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref long values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotLineU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLinedoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLinedoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLinedoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotLine(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotLineU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartFloatPtr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartFloatPtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartFloatPtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref float values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartFloatPtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartdoublePtr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartdoublePtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartdoublePtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref double values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartdoublePtr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS8Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref sbyte values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU8Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref byte values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU8Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS16Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref short values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU16Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ushort values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU16Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS32Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref int values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU32Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref uint values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU32Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS64Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref long values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartS64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte normalize = 0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU64Ptr(native_label_ids, native_values, count, x, y, radius, normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, bool normalize)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
                label_fmt_byteCount = Encoding.UTF8.GetByteCount("%.1f");
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8("%.1f", native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            double angle0 = 90;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, bool normalize, string label_fmt)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            double angle0 = 90;
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotPieChart(string[] label_ids, ref ulong values, int count, double x, double y, double radius, bool normalize, string label_fmt, double angle0)
        {
            int* label_ids_byteCounts = stackalloc int[label_ids.Length];
            int label_ids_byteCount = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                label_ids_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                label_ids_byteCount += label_ids_byteCounts[i] + 1;
            }
            byte* native_label_ids_data = stackalloc byte[label_ids_byteCount];
            int offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                string s = label_ids[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_label_ids_data + offset, label_ids_byteCounts[i]);
                    native_label_ids_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_label_ids = stackalloc byte*[label_ids.Length];
            offset = 0;
            for (int i = 0; i < label_ids.Length; i++)
            {
                native_label_ids[i] = &native_label_ids_data[offset];
                offset += label_ids_byteCounts[i] + 1;
            }
            byte native_normalize = normalize ? (byte)1 : (byte)0;
            byte* native_label_fmt;
            int label_fmt_byteCount = 0;
            if (label_fmt != null)
            {
                label_fmt_byteCount = Encoding.UTF8.GetByteCount(label_fmt);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_fmt = Util.Allocate(label_fmt_byteCount + 1);
                }
                else
                {
                    byte* native_label_fmt_stackBytes = stackalloc byte[label_fmt_byteCount + 1];
                    native_label_fmt = native_label_fmt_stackBytes;
                }
                int native_label_fmt_offset = Util.GetUtf8(label_fmt, native_label_fmt, label_fmt_byteCount);
                native_label_fmt[native_label_fmt_offset] = 0;
            }
            else { native_label_fmt = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotPieChartU64Ptr(native_label_ids, native_values, count, x, y, radius, native_normalize, native_label_fmt, angle0);
                if (label_fmt_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_fmt);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref double values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref short values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref int values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref long values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotScatterU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotScatter(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotScatterU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadeddoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadeddoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadeddoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadeddoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadeddoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadeddoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotShadedU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedFloatPtrFloatPtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadeddoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadeddoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadeddoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadeddoublePtrdoublePtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS8PtrS8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU8PtrU8PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS16PtrS16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU16PtrU16PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS32PtrS32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU32PtrU32PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedS64PtrS64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotShadedU64PtrU64PtrInt(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref float xs, ref float ys1, ref float ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys1 = &ys1)
                {
                    fixed (float* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedFloatPtrFloatPtrFloatPtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadeddoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadeddoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref double xs, ref double ys1, ref double ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys1 = &ys1)
                {
                    fixed (double* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadeddoublePtrdoublePtrdoublePtr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref sbyte xs, ref sbyte ys1, ref sbyte ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys1 = &ys1)
                {
                    fixed (sbyte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS8PtrS8PtrS8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref byte xs, ref byte ys1, ref byte ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys1 = &ys1)
                {
                    fixed (byte* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU8PtrU8PtrU8Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref short xs, ref short ys1, ref short ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys1 = &ys1)
                {
                    fixed (short* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS16PtrS16PtrS16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ushort xs, ref ushort ys1, ref ushort ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys1 = &ys1)
                {
                    fixed (ushort* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU16PtrU16PtrU16Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref int xs, ref int ys1, ref int ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys1 = &ys1)
                {
                    fixed (int* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS32PtrS32PtrS32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref uint xs, ref uint ys1, ref uint ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys1 = &ys1)
                {
                    fixed (uint* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU32PtrU32PtrU32Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref long xs, ref long ys1, ref long ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys1 = &ys1)
                {
                    fixed (long* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedS64PtrS64PtrS64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotShaded(string label_id, ref ulong xs, ref ulong ys1, ref ulong ys2, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys1 = &ys1)
                {
                    fixed (ulong* native_ys2 = &ys2)
                    {
                        ImPlotNative.ImPlot_PlotShadedU64PtrU64PtrU64Ptr(native_label_id, native_xs, native_ys1, native_ys2, count, offset, stride);
                        if (label_id_byteCount > Util.StackAllocationSizeLimit)
                        {
                            Util.Free(native_label_id);
                        }
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsFloatPtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref double values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsdoublePtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU8PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref short values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU16PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref int values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU32PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref long values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsS64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong values, int count, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStairsU64PtrInt(native_label_id, native_values, count, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref float xs, ref float ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref double xs, ref double ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref sbyte xs, ref sbyte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref byte xs, ref byte ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref short xs, ref short ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ushort xs, ref ushort ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref int xs, ref int ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref uint xs, ref uint ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref long xs, ref long ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStairs(string label_id, ref ulong xs, ref ulong ys, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStairsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsFloatPtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsdoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsdoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsdoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsdoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsdoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref double values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsdoublePtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref byte values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU8PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref short values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU16PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref int values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref uint values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU32PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref long values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsS64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double xscale = 1;
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double x0 = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong values, int count, double y_ref, double xscale, double x0, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_values = &values)
            {
                ImPlotNative.ImPlot_PlotStemsU64PtrInt(native_label_id, native_values, count, y_ref, xscale, x0, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref float xs, ref float ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                fixed (float* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsFloatPtrFloatPtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref double xs, ref double ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                fixed (double* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsdoublePtrdoublePtr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref sbyte xs, ref sbyte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                fixed (sbyte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS8PtrS8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref byte xs, ref byte ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                fixed (byte* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU8PtrU8Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref short xs, ref short ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                fixed (short* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS16PtrS16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ushort xs, ref ushort ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                fixed (ushort* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU16PtrU16Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref int xs, ref int ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                fixed (int* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS32PtrS32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref uint xs, ref uint ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                fixed (uint* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU32PtrU32Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref long xs, ref long ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                fixed (long* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsS64PtrS64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            double y_ref = 0;
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotStems(string label_id, ref ulong xs, ref ulong ys, int count, double y_ref, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                fixed (ulong* native_ys = &ys)
                {
                    ImPlotNative.ImPlot_PlotStemsU64PtrU64Ptr(native_label_id, native_xs, native_ys, count, y_ref, offset, stride);
                    if (label_id_byteCount > Util.StackAllocationSizeLimit)
                    {
                        Util.Free(native_label_id);
                    }
                }
            }
        }
        public static void PlotText(string text, double x, double y)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            byte vertical = 0;
            Vector2 pix_offset = new Vector2();
            ImPlotNative.ImPlot_PlotText(native_text, x, y, vertical, pix_offset);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static void PlotText(string text, double x, double y, bool vertical)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            Vector2 pix_offset = new Vector2();
            ImPlotNative.ImPlot_PlotText(native_text, x, y, native_vertical, pix_offset);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static void PlotText(string text, double x, double y, bool vertical, Vector2 pix_offset)
        {
            byte* native_text;
            int text_byteCount = 0;
            if (text != null)
            {
                text_byteCount = Encoding.UTF8.GetByteCount(text);
                if (text_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_text = Util.Allocate(text_byteCount + 1);
                }
                else
                {
                    byte* native_text_stackBytes = stackalloc byte[text_byteCount + 1];
                    native_text = native_text_stackBytes;
                }
                int native_text_offset = Util.GetUtf8(text, native_text, text_byteCount);
                native_text[native_text_offset] = 0;
            }
            else { native_text = null; }
            byte native_vertical = vertical ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_PlotText(native_text, x, y, native_vertical, pix_offset);
            if (text_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_text);
            }
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt)
        {
            Vector2 __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixelsPlotPoInt(&__retval, plt, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(ImPlotPoint plt, ImPlotYAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixelsPlotPoInt(&__retval, plt, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y)
        {
            Vector2 __retval;
            ImPlotYAxis y_axis = (ImPlotYAxis)(-1);
            ImPlotNative.ImPlot_PlotToPixelsdouble(&__retval, x, y, y_axis);
            return __retval;
        }
        public static Vector2 PlotToPixels(double x, double y, ImPlotYAxis y_axis)
        {
            Vector2 __retval;
            ImPlotNative.ImPlot_PlotToPixelsdouble(&__retval, x, y, y_axis);
            return __retval;
        }
        public static void PlotVLines(string label_id, ref float xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesFloatPtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref float xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(float);
            fixed (float* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesFloatPtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref float xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (float* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesFloatPtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref double xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesdoublePtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref double xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(double);
            fixed (double* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesdoublePtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref double xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (double* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesdoublePtr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref sbyte xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref sbyte xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(sbyte);
            fixed (sbyte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref sbyte xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (sbyte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref byte xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref byte xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(byte);
            fixed (byte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref byte xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (byte* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU8Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref short xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref short xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(short);
            fixed (short* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref short xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (short* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ushort xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ushort xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ushort);
            fixed (ushort* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ushort xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ushort* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU16Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref int xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref int xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(int);
            fixed (int* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref int xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (int* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref uint xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref uint xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(uint);
            fixed (uint* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref uint xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (uint* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU32Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref long xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref long xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(long);
            fixed (long* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref long xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (long* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesS64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ulong xs, int count)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int offset = 0;
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ulong xs, int count, int offset)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            int stride = sizeof(ulong);
            fixed (ulong* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PlotVLines(string label_id, ref ulong xs, int count, int offset, int stride)
        {
            byte* native_label_id;
            int label_id_byteCount = 0;
            if (label_id != null)
            {
                label_id_byteCount = Encoding.UTF8.GetByteCount(label_id);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label_id = Util.Allocate(label_id_byteCount + 1);
                }
                else
                {
                    byte* native_label_id_stackBytes = stackalloc byte[label_id_byteCount + 1];
                    native_label_id = native_label_id_stackBytes;
                }
                int native_label_id_offset = Util.GetUtf8(label_id, native_label_id, label_id_byteCount);
                native_label_id[native_label_id_offset] = 0;
            }
            else { native_label_id = null; }
            fixed (ulong* native_xs = &xs)
            {
                ImPlotNative.ImPlot_PlotVLinesU64Ptr(native_label_id, native_xs, count, offset, stride);
                if (label_id_byteCount > Util.StackAllocationSizeLimit)
                {
                    Util.Free(native_label_id);
                }
            }
        }
        public static void PopColormap()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopColormap(int count)
        {
            ImPlotNative.ImPlot_PopColormap(count);
        }
        public static void PopPlotClipRect()
        {
            ImPlotNative.ImPlot_PopPlotClipRect();
        }
        public static void PopStyleColor()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleColor(int count)
        {
            ImPlotNative.ImPlot_PopStyleColor(count);
        }
        public static void PopStyleVar()
        {
            int count = 1;
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static void PopStyleVar(int count)
        {
            ImPlotNative.ImPlot_PopStyleVar(count);
        }
        public static void PushColormap(ImPlotColormap colormap)
        {
            ImPlotNative.ImPlot_PushColormapPlotColormap(colormap);
        }
        public static void PushColormap(ref Vector4 colormap, int size)
        {
            fixed (Vector4* native_colormap = &colormap)
            {
                ImPlotNative.ImPlot_PushColormapVec4Ptr(native_colormap, size);
            }
        }
        public static void PushPlotClipRect()
        {
            ImPlotNative.ImPlot_PushPlotClipRect();
        }
        public static void PushStyleColor(ImPlotCol idx, uint col)
        {
            ImPlotNative.ImPlot_PushStyleColorU32(idx, col);
        }
        public static void PushStyleColor(ImPlotCol idx, Vector4 col)
        {
            ImPlotNative.ImPlot_PushStyleColorVec4(idx, col);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, float val)
        {
            ImPlotNative.ImPlot_PushStyleVarFloat(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, int val)
        {
            ImPlotNative.ImPlot_PushStyleVarInt(idx, val);
        }
        public static void PushStyleVar(ImPlotStyleVar idx, Vector2 val)
        {
            ImPlotNative.ImPlot_PushStyleVarVec2(idx, val);
        }
        public static void SetColormap(ref Vector4 colormap, int size)
        {
            fixed (Vector4* native_colormap = &colormap)
            {
                ImPlotNative.ImPlot_SetColormapVec4Ptr(native_colormap, size);
            }
        }
        public static void SetColormap(ImPlotColormap colormap)
        {
            int samples = 0;
            ImPlotNative.ImPlot_SetColormapPlotColormap(colormap, samples);
        }
        public static void SetColormap(ImPlotColormap colormap, int samples)
        {
            ImPlotNative.ImPlot_SetColormapPlotColormap(colormap, samples);
        }
        public static void SetCurrentContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetCurrentContext(ctx);
        }
        public static void SetImGuiContext(IntPtr ctx)
        {
            ImPlotNative.ImPlot_SetImGuiContext(ctx);
        }
        public static void SetLegendLocation(ImPlotLocation location)
        {
            ImPlotOrientation orientation = ImPlotOrientation.Vertical;
            byte outside = 0;
            ImPlotNative.ImPlot_SetLegendLocation(location, orientation, outside);
        }
        public static void SetLegendLocation(ImPlotLocation location, ImPlotOrientation orientation)
        {
            byte outside = 0;
            ImPlotNative.ImPlot_SetLegendLocation(location, orientation, outside);
        }
        public static void SetLegendLocation(ImPlotLocation location, ImPlotOrientation orientation, bool outside)
        {
            byte native_outside = outside ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetLegendLocation(location, orientation, native_outside);
        }
        public static void SetMousePosLocation(ImPlotLocation location)
        {
            ImPlotNative.ImPlot_SetMousePosLocation(location);
        }
        public static void SetNextErrorBarStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col)
        {
            float size = -1;
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextErrorBarStyle(Vector4 col, float size, float weight)
        {
            ImPlotNative.ImPlot_SetNextErrorBarStyle(col, size, weight);
        }
        public static void SetNextFillStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col)
        {
            float alpha_mod = -1;
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextFillStyle(Vector4 col, float alpha_mod)
        {
            ImPlotNative.ImPlot_SetNextFillStyle(col, alpha_mod);
        }
        public static void SetNextLineStyle()
        {
            Vector4 col = new Vector4(0, 0, 0, -1);
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col)
        {
            float weight = -1;
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextLineStyle(Vector4 col, float weight)
        {
            ImPlotNative.ImPlot_SetNextLineStyle(col, weight);
        }
        public static void SetNextMarkerStyle()
        {
            ImPlotMarker marker = (ImPlotMarker)(-1);
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker)
        {
            float size = -1;
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size)
        {
            Vector4 fill = new Vector4(0, 0, 0, -1);
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill)
        {
            float weight = -1;
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight)
        {
            Vector4 outline = new Vector4(0, 0, 0, -1);
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextMarkerStyle(ImPlotMarker marker, float size, Vector4 fill, float weight, Vector4 outline)
        {
            ImPlotNative.ImPlot_SetNextMarkerStyle(marker, size, fill, weight, outline);
        }
        public static void SetNextPlotLimits(double xmin, double xmax, double ymin, double ymax)
        {
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_SetNextPlotLimits(xmin, xmax, ymin, ymax, cond);
        }
        public static void SetNextPlotLimits(double xmin, double xmax, double ymin, double ymax, ImGuiCond cond)
        {
            ImPlotNative.ImPlot_SetNextPlotLimits(xmin, xmax, ymin, ymax, cond);
        }
        public static void SetNextPlotLimitsX(double xmin, double xmax)
        {
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotNative.ImPlot_SetNextPlotLimitsX(xmin, xmax, cond);
        }
        public static void SetNextPlotLimitsX(double xmin, double xmax, ImGuiCond cond)
        {
            ImPlotNative.ImPlot_SetNextPlotLimitsX(xmin, xmax, cond);
        }
        public static void SetNextPlotLimitsY(double ymin, double ymax)
        {
            ImGuiCond cond = ImGuiCond.Once;
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            ImPlotNative.ImPlot_SetNextPlotLimitsY(ymin, ymax, cond, y_axis);
        }
        public static void SetNextPlotLimitsY(double ymin, double ymax, ImGuiCond cond)
        {
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            ImPlotNative.ImPlot_SetNextPlotLimitsY(ymin, ymax, cond, y_axis);
        }
        public static void SetNextPlotLimitsY(double ymin, double ymax, ImGuiCond cond, ImPlotYAxis y_axis)
        {
            ImPlotNative.ImPlot_SetNextPlotLimitsY(ymin, ymax, cond, y_axis);
        }
        public static void SetNextPlotTicksX(ref double values, int n_ticks)
        {
            byte** labels = null;
            byte show_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksXdoublePtr(native_values, n_ticks, labels, show_default);
            }
        }
        public static void SetNextPlotTicksX(ref double values, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte show_default = 0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksXdoublePtr(native_values, n_ticks, native_labels, show_default);
            }
        }
        public static void SetNextPlotTicksX(ref double values, int n_ticks, string[] labels, bool show_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_show_default = show_default ? (byte)1 : (byte)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksXdoublePtr(native_values, n_ticks, native_labels, native_show_default);
            }
        }
        public static void SetNextPlotTicksX(double x_min, double x_max, int n_ticks)
        {
            byte** labels = null;
            byte show_default = 0;
            ImPlotNative.ImPlot_SetNextPlotTicksXdouble(x_min, x_max, n_ticks, labels, show_default);
        }
        public static void SetNextPlotTicksX(double x_min, double x_max, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte show_default = 0;
            ImPlotNative.ImPlot_SetNextPlotTicksXdouble(x_min, x_max, n_ticks, native_labels, show_default);
        }
        public static void SetNextPlotTicksX(double x_min, double x_max, int n_ticks, string[] labels, bool show_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_show_default = show_default ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetNextPlotTicksXdouble(x_min, x_max, n_ticks, native_labels, native_show_default);
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks)
        {
            byte** labels = null;
            byte show_default = 0;
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksYdoublePtr(native_values, n_ticks, labels, show_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte show_default = 0;
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksYdoublePtr(native_values, n_ticks, native_labels, show_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks, string[] labels, bool show_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_show_default = show_default ? (byte)1 : (byte)0;
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksYdoublePtr(native_values, n_ticks, native_labels, native_show_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(ref double values, int n_ticks, string[] labels, bool show_default, ImPlotYAxis y_axis)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_show_default = show_default ? (byte)1 : (byte)0;
            fixed (double* native_values = &values)
            {
                ImPlotNative.ImPlot_SetNextPlotTicksYdoublePtr(native_values, n_ticks, native_labels, native_show_default, y_axis);
            }
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks)
        {
            byte** labels = null;
            byte show_default = 0;
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            ImPlotNative.ImPlot_SetNextPlotTicksYdouble(y_min, y_max, n_ticks, labels, show_default, y_axis);
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks, string[] labels)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte show_default = 0;
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            ImPlotNative.ImPlot_SetNextPlotTicksYdouble(y_min, y_max, n_ticks, native_labels, show_default, y_axis);
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks, string[] labels, bool show_default)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_show_default = show_default ? (byte)1 : (byte)0;
            ImPlotYAxis y_axis = (ImPlotYAxis)0;
            ImPlotNative.ImPlot_SetNextPlotTicksYdouble(y_min, y_max, n_ticks, native_labels, native_show_default, y_axis);
        }
        public static void SetNextPlotTicksY(double y_min, double y_max, int n_ticks, string[] labels, bool show_default, ImPlotYAxis y_axis)
        {
            int* labels_byteCounts = stackalloc int[labels.Length];
            int labels_byteCount = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                labels_byteCounts[i] = Encoding.UTF8.GetByteCount(s);
                labels_byteCount += labels_byteCounts[i] + 1;
            }
            byte* native_labels_data = stackalloc byte[labels_byteCount];
            int offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                string s = labels[i];
                fixed (char* sPtr = s)
                {
                    offset += Encoding.UTF8.GetBytes(sPtr, s.Length, native_labels_data + offset, labels_byteCounts[i]);
                    native_labels_data[offset] = 0;
                    offset += 1;
                }
            }
            byte** native_labels = stackalloc byte*[labels.Length];
            offset = 0;
            for (int i = 0; i < labels.Length; i++)
            {
                native_labels[i] = &native_labels_data[offset];
                offset += labels_byteCounts[i] + 1;
            }
            byte native_show_default = show_default ? (byte)1 : (byte)0;
            ImPlotNative.ImPlot_SetNextPlotTicksYdouble(y_min, y_max, n_ticks, native_labels, native_show_default, y_axis);
        }
        public static void SetPlotYAxis(ImPlotYAxis y_axis)
        {
            ImPlotNative.ImPlot_SetPlotYAxis(y_axis);
        }
        public static void ShowColormapScale(double scale_min, double scale_max)
        {
            Vector2 size = new Vector2();
            ImPlotNative.ImPlot_ShowColormapScale(scale_min, scale_max, size);
        }
        public static void ShowColormapScale(double scale_min, double scale_max, Vector2 size)
        {
            ImPlotNative.ImPlot_ShowColormapScale(scale_min, scale_max, size);
        }
        public static bool ShowColormapSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowColormapSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowDemoWindow()
        {
            byte* p_open = null;
            ImPlotNative.ImPlot_ShowDemoWindow(p_open);
        }
        public static void ShowDemoWindow(ref bool p_open)
        {
            byte native_p_open_val = p_open ? (byte)1 : (byte)0;
            byte* native_p_open = &native_p_open_val;
            ImPlotNative.ImPlot_ShowDemoWindow(native_p_open);
            p_open = native_p_open_val != 0;
        }
        public static void ShowMetricsWindow()
        {
            byte* p_popen = null;
            ImPlotNative.ImPlot_ShowMetricsWindow(p_popen);
        }
        public static void ShowMetricsWindow(ref bool p_popen)
        {
            byte native_p_popen_val = p_popen ? (byte)1 : (byte)0;
            byte* native_p_popen = &native_p_popen_val;
            ImPlotNative.ImPlot_ShowMetricsWindow(native_p_popen);
            p_popen = native_p_popen_val != 0;
        }
        public static void ShowStyleEditor()
        {
            ImPlotStyle* @ref = null;
            ImPlotNative.ImPlot_ShowStyleEditor(@ref);
        }
        public static void ShowStyleEditor(ImPlotStylePtr @ref)
        {
            ImPlotStyle* native_ref = @ref.NativePtr;
            ImPlotNative.ImPlot_ShowStyleEditor(native_ref);
        }
        public static bool ShowStyleSelector(string label)
        {
            byte* native_label;
            int label_byteCount = 0;
            if (label != null)
            {
                label_byteCount = Encoding.UTF8.GetByteCount(label);
                if (label_byteCount > Util.StackAllocationSizeLimit)
                {
                    native_label = Util.Allocate(label_byteCount + 1);
                }
                else
                {
                    byte* native_label_stackBytes = stackalloc byte[label_byteCount + 1];
                    native_label = native_label_stackBytes;
                }
                int native_label_offset = Util.GetUtf8(label, native_label, label_byteCount);
                native_label[native_label_offset] = 0;
            }
            else { native_label = null; }
            byte ret = ImPlotNative.ImPlot_ShowStyleSelector(native_label);
            if (label_byteCount > Util.StackAllocationSizeLimit)
            {
                Util.Free(native_label);
            }
            return ret != 0;
        }
        public static void ShowUserGuide()
        {
            ImPlotNative.ImPlot_ShowUserGuide();
        }
        public static void StyleColorsAuto()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsAuto(dst);
        }
        public static void StyleColorsAuto(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsAuto(native_dst);
        }
        public static void StyleColorsClassic()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsClassic(dst);
        }
        public static void StyleColorsClassic(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsClassic(native_dst);
        }
        public static void StyleColorsDark()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsDark(dst);
        }
        public static void StyleColorsDark(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsDark(native_dst);
        }
        public static void StyleColorsLight()
        {
            ImPlotStyle* dst = null;
            ImPlotNative.ImPlot_StyleColorsLight(dst);
        }
        public static void StyleColorsLight(ImPlotStylePtr dst)
        {
            ImPlotStyle* native_dst = dst.NativePtr;
            ImPlotNative.ImPlot_StyleColorsLight(native_dst);
        }
    }
}
